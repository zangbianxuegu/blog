<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>zangbianxuegu - 语句和表达式</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://unpkg.com/tachyons@4.7.4/css/tachyons.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/default.min.css"/><link rel="stylesheet" href="static/css/common.css"/><style>
          body {
            font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;
          }
      </style><meta name="next-head-count" content="8"/><link rel="preload" href="/_next/static/iu6_5DrOPmhFOAN3PQyRD/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/iu6_5DrOPmhFOAN3PQyRD/pages/post.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-58a9a31aff66d1589179.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.e84fa698c7ee940652bd.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.34684228d50c6c140f9e.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-5879c6e8fc5fb6f8f0ea.js" as="script"/><link rel="preload" href="/_next/static/chunks/37fdf20fe8abb7e95e7de40a8be29264464a11e4.d421cefb44a0017721ac.js" as="script"/></head><body><div id="__next"><div><div><main class="lh-copy"><div class="relative tc header-bg bg-dark-gray"><div class="mw7 center white pv4"><div class="pv4"><h1 class="f1 normal lh-title ma0 pa0"><a class="white no-underline" href="/">zangbianxuegu</a></h1><h4 class="normal o-70 ma0 pt2 pb3 ph1"></h4><div><a class="dib f6 white no-underline pa1 ma1" href="https://zangbianxuegu.github.io/">Home</a><a class="dib f6 white no-underline pa1 ma1" href="https://github.com/zangbianxuegu/">Github</a><a class="dib f6 white no-underline pa1 ma1" href="https://twitter.com/zangbianxuegu">Twitter</a><a class="dib f6 white no-underline pa1 ma1" href="https://www.douban.com/people/zangbianxuegu/">豆瓣</a></div></div></div></div><div class="content center mw8 pa3 pa4-ns"><h1 class="mt0 lh-title title">语句和表达式</h1><div><h2>语句</h2>
<p><strong>wiki 语句</strong></p>
<p>语句（计算机科学）：<a href="https://en.wikipedia.org/wiki/Statement_(computer_science)">https://en.wikipedia.org/wiki/Statement_(computer_science)</a>
​
语句是命令式编程语言的一个语法单元，表示程序要执行的操作。程序是有一个或多个语句序列，语句可能包含内部组件（例如表达式）。</p>
<p>语句决定了程序的外观，编程语言表现为它们使用的语句类型（例如花括号），许多语句由标识符 if、while 或者 repeat 引入，语句关键字是保留的。</p>
<p>大多数语言中，语句和表达式的区别在于，语句不返回结果，执行语句只是为了产生副作用，而表达式总是返回结果，而通常没有副作用。</p>
<p>在命令式编程语言中，Algol 68 是少数几种语句可以返回结果的语言之一。在混合了命令式和函数式风格的语言中，如 Lisp 家族，表达式和语句之间没有区别。在纯函数式编程中，没有语句，一切都是表达式。</p>
<p>这种区别经常表现为：执行语句，而计算表达式。这可以在某些语言中的 exec 和 eval 函数中找到：在 Python 中，exec 应用于语句，eval 应用于表达式。</p>
<h2>表达式</h2>
<p><strong>wiki 表达式</strong></p>
<p>表达式（数学）：<a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%BC%8F">https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%BC%8F</a>
​
表示式亦称表达式、运算式或数学表达式，在数学领域中是一些符号依据上下文的规则，有限而定义良好的组合。数学符号可用于标定数字（常量）、变量、操作、函数、括号、标点符号和分组，帮助确定操作顺序以及有其它考量的逻辑语法。</p>
<p><strong>范例：</strong></p>
<p>表达式的使用范围从简单的如下列各例：</p>
<p><img src="https://pic3.zhimg.com/v2-4855ddb31654bcef587d874427bffe5e_b.png" alt="表达式范例"></p>
<p>表达式是一个句法结构，它必须具有良好定义的形式。表达式中的运算符必须在正确位置有正确的输入数，组成这些输入的字符必须是有效的，具有明确的运算次序等。违反语法规则的字符，不会构成有效的数学表达式。例如，在一般算术符号中，表达式 1 + 2 × 3 是形式良好的，但下面的表达式却没有：</p>
<blockquote>
<p>*4)x+,/y.</p>
</blockquote>
<p><strong>wiki 表达式</strong></p>
<p>表达式（计算机科学）：<a href="https://en.wikipedia.org/wiki/Expression_(computer_science)">https://en.wikipedia.org/wiki/Expression_(computer_science)</a>
​
表达式是一个或多个常量、变量、运算符和函数的组合，编程语言根据其特定的优先级和关联规则解释它们，并计算它们来生成另外一个值。这个过程，在数学表达式中被称为求值。</p>
<p>在简单设置中，得到的值通常是基本类型的一种，例如数字、字符串、布尔值、复杂数据类型或者其他。</p>
<p>关于语句和表达式的区别，说成是表达式有值而语句不总有没错，但是我也认为以下这种理解很好：</p>
<p><a href="https://www.zhihu.com/question/20750344/answer/487107831">在编程概念中，表达式和语句分别是什么概念？ - 唐朝稻草人的回答 - 知乎</a></p>
<h2>JavaScript 中的语句与表达式</h2>
<p>参考：<a href="https://2ality.com/2012/09/expressions-vs-statements.html">Expressions versus statements in JavaScript</a>
​
表达式产生一个值，可以写在任何需要一个值的地方。而语句是一个行为，例如循环和条件语句，一个程序基本上就是一个语句序列。任何需要语句的地方，也可以写表达式，这样的语句是<strong>表达式语句</strong>。反过来却不行：你不能在需要表达式的时候使用语句，例如一个 if 语句不能作为函数的参数。</p>
<p>以下是一个 if 语句：</p>
<pre><code class="hljs"><span class="hljs-keyword">var</span> x
<span class="hljs-keyword">if</span> (y &gt;= <span class="hljs-number">0</span>) {
  x = y
} <span class="hljs-keyword">else</span> {
  x = -y
}</code></pre><p>等价于下面的表达式：</p>
<pre><code class="hljs"><span class="hljs-keyword">var</span> x = y &gt;= <span class="hljs-number">0</span> ? y : -y</code></pre><p><code>=</code>与<code>;</code>之间的代码就是一个表达式。</p>
<p>在 JavaScript 中，使用分号连接语句：</p>
<pre><code class="hljs">foo()
bar()</code></pre><p>在表达式中，使用逗号：</p>
<pre><code class="hljs">foo(), bar()</code></pre><p>逗号会计算两边的表达式并返回第二个表达式的结果：</p>
<pre><code class="hljs">&gt; <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>
<span class="hljs-string">'b'</span>

&gt; <span class="hljs-keyword">var</span> x = (<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>);
&gt; x
<span class="hljs-string">'b'</span>

&gt; <span class="hljs-built_in">console</span>.log((<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>));
b</code></pre><h3>看似语句的表达式</h3>
<h4>对象字面量和语句块</h4>
<p>下面是一个对象字面量，可以生成一个对象的表达式</p>
<pre><code class="hljs">{
  foo: bar(3, 5)
}</code></pre><p>然而，它也是一个合法的语句，包含以下组件：</p>
<ul>
<li>一个代码块：花括号内的语句</li>
<li>一个标签：语句的前缀 foo</li>
<li>一个语句：表达式语句 bar(3, 5)</li>
</ul>
<p>JavaScript 拥有独立存在的代码块（而非循环或 if 语句的一部分）。例如：</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">printTwo</span>) </span>{
  <span class="hljs-attr">printing</span>: {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'One'</span>)
    <span class="hljs-keyword">if</span> (!printTwo) <span class="hljs-keyword">break</span> printing
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Two'</span>)
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Three'</span>)
}</code></pre><h4>函数表达式和函数声明</h4>
<p>以下是函数表达式：</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ }</code></pre><p>你可以给函数表达式一个名字使之变为命名函数表达式：</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{}</code></pre><p>命名函数表达式和函数声明没有什么区别。但是它们的效果是不同的：一个函数表达式产生一个值（这个函数），而一个函数声明导致一个行为——创建一个变量，它的值是这个函数。<strong>此外，一个函数表达式可以立即执行，函数声明不行。</strong></p>
<h6>解释</h6>
<p><code>function foo () {}</code>，是函数声明，不能执行 <code>function foo () {} ()</code>。<code>let foo = function () {}</code>，函数表达式 <code>function () {}</code> 也即是 <code>foo</code>，可以执行 <code>foo()</code>。</p>
<h3>函数表达式和函数声明</h3>
<h4>函数声明</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function</a>
​
<strong>函数声明</strong>定义一个具有指定参数的函数。</p>
<p>语法：</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span>(<span class="hljs-params">[param,[, param,[..., param]]]</span>) </span>{
  [statements]
}</code></pre><p><code>name</code>：函数名
<code>param</code>：要传递给函数的参数的名称。不同引擎中的最大参数数量不同。
<code>statements</code>：包含函数体的语句。</p>
<p>函数声明或被提升到被包含的函数或全局作用域顶部，可以在声明前使用：</p>
<pre><code class="hljs">hoisted() <span class="hljs-comment">// "foo"</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hoisted</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>)
}

<span class="hljs-comment">/* equal to*/</span>
<span class="hljs-keyword">var</span> hoisted
hoisted = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>)
}
hoisted()
<span class="hljs-comment">// "foo"</span></code></pre><p>而函数表达式不会被提升：</p>
<pre><code class="hljs">notHoisted() <span class="hljs-comment">// TypeError: notHoisted is not a function</span>
<span class="hljs-keyword">var</span> notHoisted = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bar'</span>)
}</code></pre><h4>函数表达式</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function</a>
​
语法：</p>
<pre><code class="hljs">let function*expression = function [name]([param1[, param2[, ..., paramN]]]) {
  statements
};</code></pre><p><code>name</code>：函数名称。可被省略，此种情况下的函数是匿名函数（anonymous）。 函数名称只是函数体中的一个本地变量。
<code>paramN</code>：被传递给函数的一个参数名称。一个函数至多拥有 255 个参数。
<code>statements</code>：构成函数体的语句。</p>
<p><strong>从以上对比可以发现，函数表达式非常类似函数声明，唯一的区别就是函数名称可以省略，从而创建匿名函数。</strong></p>
<p>函数名称类似变量，会提升，不同的是，对于函数声明，变量（函数名称）会和变量赋值（函数体）一起提升，而变量不会，只提升变量声明。</p>
<p>以下是一个<strong>命名函数表达式</strong>，应用于递归中自我调用：</p>
<pre><code class="hljs"><span class="hljs-keyword">var</span> math = {
  <span class="hljs-string">'factorial'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> n \* factorial(n - <span class="hljs-number">1</span>);
  }
};</code></pre><p>被函数表达式赋值的那个变量会有一个 name 属性，如果你把这个变量赋值给另一个变量的话，这个 name 属性的值也不会改变。</p>
<pre><code class="hljs"><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
foo.name <span class="hljs-comment">// "foo"</span>
;(<span class="hljs-string">'foo'</span>)
foo.name = <span class="hljs-string">'aaa'</span>
;(<span class="hljs-string">'aaa'</span>)
foo.name
;(<span class="hljs-string">'foo'</span>)</code></pre><p>实际上被赋值的变量引用了函数，函数名称是不变的。</p>
<p>函数表达式更多被当做回调函数使用：</p>
<pre><code class="hljs">button.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'button is clicked!'</span>)
})</code></pre><p>函数声明就是语句，<code>function foo () {}</code>，而函数表达式，<code>function () {}</code>，本身是一个值，所以在回调中无法使用函数声明。</p>
<h3>使用对象字面量和函数表达式作为语句</h3>
<p>我们已经看到，一些表达式和语句是无法区分的，相同的代码作用不同，这取决于它出现在表达式上下文会还是语句上下文中。通常这两个上下文是明显分开的。但是，对于表达式语句，会有重叠：在这里，表达式出现在语句上下文中。为了避免歧义，JavaScript 语法禁止表达式语句以花括号或关键字 function 开头。</p>
<p>但是，如果你想写一个以 <code>{</code> 或 <code>functon</code> 开头的表达式语句呢？ <strong>你可以将它放在圆括号中，这样不会改变它的结果，而且可以确保它出现在表达式（expression-only）上下文中</strong>。看两个例子：<code>eval</code> 和立即执行函数表达式（<code>IIFE</code>）。</p>
<h4>eval</h4>
<p>eval 在语句上下文中解析它的参数。如果你想让 eval 返回一个对象，可以给对象字面量加上圆括号：</p>
<pre><code class="hljs"><span class="hljs-built_in">eval</span>(<span class="hljs-string">'{ foo: 123 }'</span>)
<span class="hljs-number">123</span>
<span class="hljs-built_in">eval</span>(<span class="hljs-string">'({ foo: 123 })'</span>)
{
  <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span>
}</code></pre><h4>立即执行函数表达式（IIFEs）</h4>
<p>以下是一个立即执行函数表达式：</p>
<pre><code class="hljs">;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'abc'</span>
})()
<span class="hljs-comment">// 'abc'</span></code></pre><p>如果省略括号，就会出现语法错误（函数声明不能是匿名的）：</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">"abc"</span> }()
<span class="hljs-attr">VM6752</span>:<span class="hljs-number">1</span> Uncaught <span class="hljs-built_in">SyntaxError</span>: <span class="hljs-built_in">Function</span> statements <span class="hljs-built_in">require</span> a <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span></span></code></pre><p>如果加上名字，仍然报错（函数声明不能立即执行）：</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">"abc"</span> }()
<span class="hljs-attr">VM6757</span>:<span class="hljs-number">1</span> Uncaught <span class="hljs-built_in">SyntaxError</span>: Unexpected token )</code></pre><p>另一个确保表达式在表达式上下文中被解析的方式是使用一元运算符，如 <code>+</code> 或 <code>!</code>。但是和圆括号相反，这些运算符会改变表达式结果。如果不需要也 OK。</p>
<pre><code class="hljs">+<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello"</span>) }()
<span class="hljs-attr">VM6762</span>:<span class="hljs-number">1</span> hello
<span class="hljs-literal">NaN</span></code></pre><p>所以，IIFEs 的原理是：函数本不能作为表达式出现（指值 <code>function () {}</code>，而不是表达式 <code>let foo = function () {}</code>），但是要立即执行函数，可以将其转为表达式，圆括号将其变为表达式。</p>
<h4>连接 IIFEs</h4>
<p>连接 IIFEs，不要忘记分号：</p>
<pre><code class="hljs">;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{})()((<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{})())
<span class="hljs-comment">// TypeError: undefined is not a function</span></code></pre><h2>参考</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Statement*(computer*science)">https://en.wikipedia.org/wiki/Statement*(computer*science)</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%BC%8F">https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%BC%8F</a></li>
<li><a href="https://en.wikipedia.org/wiki/Expression*(computer_science)">https://en.wikipedia.org/wiki/Expression*(computer_science)</a></li>
<li><a href="https://www.zhihu.com/question/20750344/answer/487107831">https://www.zhihu.com/question/20750344/answer/487107831</a></li>
<li><a href="https://2ality.com/2012/09/expressions-vs-statements.html">https://2ality.com/2012/09/expressions-vs-statements.html</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function</a></li>
</ul>
</div></div><footer class="center w5 f6 tc mt4"><p><span>© </span><span>2020<!-- --> </span><span>Tim Scanlin</span></p></footer></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"pageJson":{"title":"语句和表达式","date":"2019-08-09T00:00:00.000Z","page":"post","paths":["/statement-and-expression"],"bodyContent":"## 语句\n\n**wiki 语句**\n\n语句（计算机科学）：[https://en.wikipedia.org/wiki/Statement\\_(computer_science)](\u003chttps://en.wikipedia.org/wiki/Statement_(computer_science)\u003e)\n​\n语句是命令式编程语言的一个语法单元，表示程序要执行的操作。程序是有一个或多个语句序列，语句可能包含内部组件（例如表达式）。\n\n语句决定了程序的外观，编程语言表现为它们使用的语句类型（例如花括号），许多语句由标识符 if、while 或者 repeat 引入，语句关键字是保留的。\n\n大多数语言中，语句和表达式的区别在于，语句不返回结果，执行语句只是为了产生副作用，而表达式总是返回结果，而通常没有副作用。\n\n在命令式编程语言中，Algol 68 是少数几种语句可以返回结果的语言之一。在混合了命令式和函数式风格的语言中，如 Lisp 家族，表达式和语句之间没有区别。在纯函数式编程中，没有语句，一切都是表达式。\n\n这种区别经常表现为：执行语句，而计算表达式。这可以在某些语言中的 exec 和 eval 函数中找到：在 Python 中，exec 应用于语句，eval 应用于表达式。\n\n## 表达式\n\n**wiki 表达式**\n\n表达式（数学）：[https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%BC%8F](https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%BC%8F)\n​\n表示式亦称表达式、运算式或数学表达式，在数学领域中是一些符号依据上下文的规则，有限而定义良好的组合。数学符号可用于标定数字（常量）、变量、操作、函数、括号、标点符号和分组，帮助确定操作顺序以及有其它考量的逻辑语法。\n\n**范例：**\n\n表达式的使用范围从简单的如下列各例：\n\n![表达式范例](https://pic3.zhimg.com/v2-4855ddb31654bcef587d874427bffe5e_b.png)\n\n表达式是一个句法结构，它必须具有良好定义的形式。表达式中的运算符必须在正确位置有正确的输入数，组成这些输入的字符必须是有效的，具有明确的运算次序等。违反语法规则的字符，不会构成有效的数学表达式。例如，在一般算术符号中，表达式 1 + 2 × 3 是形式良好的，但下面的表达式却没有：\n\n\u003e \\*4)x+,/y.\n\n**wiki 表达式**\n\n表达式（计算机科学）：[https://en.wikipedia.org/wiki/Expression\\_(computer_science)](\u003chttps://en.wikipedia.org/wiki/Expression_(computer_science)\u003e)\n​\n表达式是一个或多个常量、变量、运算符和函数的组合，编程语言根据其特定的优先级和关联规则解释它们，并计算它们来生成另外一个值。这个过程，在数学表达式中被称为求值。\n\n在简单设置中，得到的值通常是基本类型的一种，例如数字、字符串、布尔值、复杂数据类型或者其他。\n\n关于语句和表达式的区别，说成是表达式有值而语句不总有没错，但是我也认为以下这种理解很好：\n\n[在编程概念中，表达式和语句分别是什么概念？ - 唐朝稻草人的回答 - 知乎](https://www.zhihu.com/question/20750344/answer/487107831)\n\n## JavaScript 中的语句与表达式\n\n参考：[Expressions versus statements in JavaScript](https://2ality.com/2012/09/expressions-vs-statements.html)\n​\n表达式产生一个值，可以写在任何需要一个值的地方。而语句是一个行为，例如循环和条件语句，一个程序基本上就是一个语句序列。任何需要语句的地方，也可以写表达式，这样的语句是**表达式语句**。反过来却不行：你不能在需要表达式的时候使用语句，例如一个 if 语句不能作为函数的参数。\n\n以下是一个 if 语句：\n\n```javascript\nvar x\nif (y \u003e= 0) {\n  x = y\n} else {\n  x = -y\n}\n```\n\n等价于下面的表达式：\n\n```javascript\nvar x = y \u003e= 0 ? y : -y\n```\n\n`=`与`;`之间的代码就是一个表达式。\n\n在 JavaScript 中，使用分号连接语句：\n\n```javascript\nfoo()\nbar()\n```\n\n在表达式中，使用逗号：\n\n```javascript\nfoo(), bar()\n```\n\n逗号会计算两边的表达式并返回第二个表达式的结果：\n\n```javascript\n\u003e \"a\", \"b\"\n'b'\n\n\u003e var x = (\"a\", \"b\");\n\u003e x\n'b'\n\n\u003e console.log((\"a\", \"b\"));\nb\n```\n\n### 看似语句的表达式\n\n#### 对象字面量和语句块\n\n下面是一个对象字面量，可以生成一个对象的表达式\n\n```javascript\n{\n  foo: bar(3, 5)\n}\n```\n\n然而，它也是一个合法的语句，包含以下组件：\n\n- 一个代码块：花括号内的语句\n- 一个标签：语句的前缀 foo\n- 一个语句：表达式语句 bar(3, 5)\n\nJavaScript 拥有独立存在的代码块（而非循环或 if 语句的一部分）。例如：\n\n```javascript\nfunction test(printTwo) {\n  printing: {\n    console.log('One')\n    if (!printTwo) break printing\n    console.log('Two')\n  }\n  console.log('Three')\n}\n```\n\n#### 函数表达式和函数声明\n\n以下是函数表达式：\n\n```javascript\nfunction () { }\n```\n\n你可以给函数表达式一个名字使之变为命名函数表达式：\n\n```javascript\nfunction foo() {}\n```\n\n命名函数表达式和函数声明没有什么区别。但是它们的效果是不同的：一个函数表达式产生一个值（这个函数），而一个函数声明导致一个行为——创建一个变量，它的值是这个函数。**此外，一个函数表达式可以立即执行，函数声明不行。**\n\n###### 解释\n\n`function foo () {}`，是函数声明，不能执行 `function foo () {} ()`。`let foo = function () {}`，函数表达式 `function () {}` 也即是 `foo`，可以执行 `foo()`。\n\n### 函数表达式和函数声明\n\n#### 函数声明\n\n[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function)\n​\n**函数声明**定义一个具有指定参数的函数。\n\n语法：\n\n```javascript\nfunction name([param,[, param,[..., param]]]) {\n  [statements]\n}\n```\n\n`name`：函数名\n`param`：要传递给函数的参数的名称。不同引擎中的最大参数数量不同。\n`statements`：包含函数体的语句。\n\n函数声明或被提升到被包含的函数或全局作用域顶部，可以在声明前使用：\n\n```javascript\nhoisted() // \"foo\"\nfunction hoisted() {\n  console.log('foo')\n}\n\n/* equal to*/\nvar hoisted\nhoisted = function () {\n  console.log('foo')\n}\nhoisted()\n// \"foo\"\n```\n\n而函数表达式不会被提升：\n\n```javascript\nnotHoisted() // TypeError: notHoisted is not a function\nvar notHoisted = function () {\n  console.log('bar')\n}\n```\n\n#### 函数表达式\n\n[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function)\n​\n语法：\n\n```javascript\nlet function*expression = function [name]([param1[, param2[, ..., paramN]]]) {\n  statements\n};\n```\n\n`name`：函数名称。可被省略，此种情况下的函数是匿名函数（anonymous）。 函数名称只是函数体中的一个本地变量。\n`paramN`：被传递给函数的一个参数名称。一个函数至多拥有 255 个参数。\n`statements`：构成函数体的语句。\n\n**从以上对比可以发现，函数表达式非常类似函数声明，唯一的区别就是函数名称可以省略，从而创建匿名函数。**\n\n函数名称类似变量，会提升，不同的是，对于函数声明，变量（函数名称）会和变量赋值（函数体）一起提升，而变量不会，只提升变量声明。\n\n以下是一个**命名函数表达式**，应用于递归中自我调用：\n\n```javascript\nvar math = {\n  'factorial': function factorial(n) {\n  if (n \u003c= 1)\n    return 1;\n  return n \\* factorial(n - 1);\n  }\n};\n```\n\n被函数表达式赋值的那个变量会有一个 name 属性，如果你把这个变量赋值给另一个变量的话，这个 name 属性的值也不会改变。\n\n```javascript\nvar foo = function () {}\nfoo.name // \"foo\"\n;('foo')\nfoo.name = 'aaa'\n;('aaa')\nfoo.name\n;('foo')\n```\n\n实际上被赋值的变量引用了函数，函数名称是不变的。\n\n函数表达式更多被当做回调函数使用：\n\n```javascript\nbutton.addEventListener('click', function (event) {\n  console.log('button is clicked!')\n})\n```\n\n函数声明就是语句，`function foo () {}`，而函数表达式，`function () {}`，本身是一个值，所以在回调中无法使用函数声明。\n\n### 使用对象字面量和函数表达式作为语句\n\n我们已经看到，一些表达式和语句是无法区分的，相同的代码作用不同，这取决于它出现在表达式上下文会还是语句上下文中。通常这两个上下文是明显分开的。但是，对于表达式语句，会有重叠：在这里，表达式出现在语句上下文中。为了避免歧义，JavaScript 语法禁止表达式语句以花括号或关键字 function 开头。\n\n但是，如果你想写一个以 `{` 或 `functon` 开头的表达式语句呢？ **你可以将它放在圆括号中，这样不会改变它的结果，而且可以确保它出现在表达式（expression-only）上下文中**。看两个例子：`eval` 和立即执行函数表达式（`IIFE`）。\n\n#### eval\n\neval 在语句上下文中解析它的参数。如果你想让 eval 返回一个对象，可以给对象字面量加上圆括号：\n\n```javascript\neval('{ foo: 123 }')\n123\neval('({ foo: 123 })')\n{\n  foo: 123\n}\n```\n\n#### 立即执行函数表达式（IIFEs）\n\n以下是一个立即执行函数表达式：\n\n```javascript\n;(function () {\n  return 'abc'\n})()\n// 'abc'\n```\n\n如果省略括号，就会出现语法错误（函数声明不能是匿名的）：\n\n```javascript\nfunction () { return \"abc\" }()\nVM6752:1 Uncaught SyntaxError: Function statements require a function name\n```\n\n如果加上名字，仍然报错（函数声明不能立即执行）：\n\n```javascript\nfunction foo() { return \"abc\" }()\nVM6757:1 Uncaught SyntaxError: Unexpected token )\n```\n\n另一个确保表达式在表达式上下文中被解析的方式是使用一元运算符，如 `+` 或 `!`。但是和圆括号相反，这些运算符会改变表达式结果。如果不需要也 OK。\n\n```javascript\n+function () { console.log(\"hello\") }()\nVM6762:1 hello\nNaN\n```\n\n所以，IIFEs 的原理是：函数本不能作为表达式出现（指值 `function () {}`，而不是表达式 `let foo = function () {}`），但是要立即执行函数，可以将其转为表达式，圆括号将其变为表达式。\n\n#### 连接 IIFEs\n\n连接 IIFEs，不要忘记分号：\n\n```javascript\n;(function () {})()((function () {})())\n// TypeError: undefined is not a function\n```\n\n## 参考\n\n- [https://en.wikipedia.org/wiki/Statement*(computer*science)](\u003chttps://en.wikipedia.org/wiki/Statement*(computer*science)\u003e)\n- [https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%BC%8F](https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%BC%8F)\n- [https://en.wikipedia.org/wiki/Expression\\*(computer_science)](\u003chttps://en.wikipedia.org/wiki/Expression*(computer_science)\u003e)\n- [https://www.zhihu.com/question/20750344/answer/487107831](https://www.zhihu.com/question/20750344/answer/487107831)\n- [https://2ality.com/2012/09/expressions-vs-statements.html](https://2ality.com/2012/09/expressions-vs-statements.html)\n- [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function)\n- [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function)","bodyHtml":"\u003ch2\u003e语句\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003ewiki 语句\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e语句（计算机科学）：\u003ca href=\"https://en.wikipedia.org/wiki/Statement_(computer_science)\"\u003ehttps://en.wikipedia.org/wiki/Statement_(computer_science)\u003c/a\u003e\n​\n语句是命令式编程语言的一个语法单元，表示程序要执行的操作。程序是有一个或多个语句序列，语句可能包含内部组件（例如表达式）。\u003c/p\u003e\n\u003cp\u003e语句决定了程序的外观，编程语言表现为它们使用的语句类型（例如花括号），许多语句由标识符 if、while 或者 repeat 引入，语句关键字是保留的。\u003c/p\u003e\n\u003cp\u003e大多数语言中，语句和表达式的区别在于，语句不返回结果，执行语句只是为了产生副作用，而表达式总是返回结果，而通常没有副作用。\u003c/p\u003e\n\u003cp\u003e在命令式编程语言中，Algol 68 是少数几种语句可以返回结果的语言之一。在混合了命令式和函数式风格的语言中，如 Lisp 家族，表达式和语句之间没有区别。在纯函数式编程中，没有语句，一切都是表达式。\u003c/p\u003e\n\u003cp\u003e这种区别经常表现为：执行语句，而计算表达式。这可以在某些语言中的 exec 和 eval 函数中找到：在 Python 中，exec 应用于语句，eval 应用于表达式。\u003c/p\u003e\n\u003ch2\u003e表达式\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003ewiki 表达式\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e表达式（数学）：\u003ca href=\"https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%BC%8F\"\u003ehttps://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%BC%8F\u003c/a\u003e\n​\n表示式亦称表达式、运算式或数学表达式，在数学领域中是一些符号依据上下文的规则，有限而定义良好的组合。数学符号可用于标定数字（常量）、变量、操作、函数、括号、标点符号和分组，帮助确定操作顺序以及有其它考量的逻辑语法。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e范例：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e表达式的使用范围从简单的如下列各例：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://pic3.zhimg.com/v2-4855ddb31654bcef587d874427bffe5e_b.png\" alt=\"表达式范例\"\u003e\u003c/p\u003e\n\u003cp\u003e表达式是一个句法结构，它必须具有良好定义的形式。表达式中的运算符必须在正确位置有正确的输入数，组成这些输入的字符必须是有效的，具有明确的运算次序等。违反语法规则的字符，不会构成有效的数学表达式。例如，在一般算术符号中，表达式 1 + 2 × 3 是形式良好的，但下面的表达式却没有：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e*4)x+,/y.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003ewiki 表达式\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e表达式（计算机科学）：\u003ca href=\"https://en.wikipedia.org/wiki/Expression_(computer_science)\"\u003ehttps://en.wikipedia.org/wiki/Expression_(computer_science)\u003c/a\u003e\n​\n表达式是一个或多个常量、变量、运算符和函数的组合，编程语言根据其特定的优先级和关联规则解释它们，并计算它们来生成另外一个值。这个过程，在数学表达式中被称为求值。\u003c/p\u003e\n\u003cp\u003e在简单设置中，得到的值通常是基本类型的一种，例如数字、字符串、布尔值、复杂数据类型或者其他。\u003c/p\u003e\n\u003cp\u003e关于语句和表达式的区别，说成是表达式有值而语句不总有没错，但是我也认为以下这种理解很好：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.zhihu.com/question/20750344/answer/487107831\"\u003e在编程概念中，表达式和语句分别是什么概念？ - 唐朝稻草人的回答 - 知乎\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003eJavaScript 中的语句与表达式\u003c/h2\u003e\n\u003cp\u003e参考：\u003ca href=\"https://2ality.com/2012/09/expressions-vs-statements.html\"\u003eExpressions versus statements in JavaScript\u003c/a\u003e\n​\n表达式产生一个值，可以写在任何需要一个值的地方。而语句是一个行为，例如循环和条件语句，一个程序基本上就是一个语句序列。任何需要语句的地方，也可以写表达式，这样的语句是\u003cstrong\u003e表达式语句\u003c/strong\u003e。反过来却不行：你不能在需要表达式的时候使用语句，例如一个 if 语句不能作为函数的参数。\u003c/p\u003e\n\u003cp\u003e以下是一个 if 语句：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (y \u0026gt;= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n  x = y\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  x = -y\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e等价于下面的表达式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x = y \u0026gt;= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e ? y : -y\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e=\u003c/code\u003e与\u003ccode\u003e;\u003c/code\u003e之间的代码就是一个表达式。\u003c/p\u003e\n\u003cp\u003e在 JavaScript 中，使用分号连接语句：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003efoo()\nbar()\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在表达式中，使用逗号：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003efoo(), bar()\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e逗号会计算两边的表达式并返回第二个表达式的结果：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u0026gt; \u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"b\"\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e\n\n\u0026gt; \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x = (\u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"b\"\u003c/span\u003e);\n\u0026gt; x\n\u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e\n\n\u0026gt; \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log((\u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"b\"\u003c/span\u003e));\nb\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e看似语句的表达式\u003c/h3\u003e\n\u003ch4\u003e对象字面量和语句块\u003c/h4\u003e\n\u003cp\u003e下面是一个对象字面量，可以生成一个对象的表达式\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e{\n  foo: bar(3, 5)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e然而，它也是一个合法的语句，包含以下组件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一个代码块：花括号内的语句\u003c/li\u003e\n\u003cli\u003e一个标签：语句的前缀 foo\u003c/li\u003e\n\u003cli\u003e一个语句：表达式语句 bar(3, 5)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eJavaScript 拥有独立存在的代码块（而非循环或 if 语句的一部分）。例如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprintTwo\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-attr\"\u003eprinting\u003c/span\u003e: {\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'One'\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!printTwo) \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e printing\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'Two'\u003c/span\u003e)\n  }\n  \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'Three'\u003c/span\u003e)\n}\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e函数表达式和函数声明\u003c/h4\u003e\n\u003cp\u003e以下是函数表达式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{ }\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e你可以给函数表达式一个名字使之变为命名函数表达式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e命名函数表达式和函数声明没有什么区别。但是它们的效果是不同的：一个函数表达式产生一个值（这个函数），而一个函数声明导致一个行为——创建一个变量，它的值是这个函数。\u003cstrong\u003e此外，一个函数表达式可以立即执行，函数声明不行。\u003c/strong\u003e\u003c/p\u003e\n\u003ch6\u003e解释\u003c/h6\u003e\n\u003cp\u003e\u003ccode\u003efunction foo () {}\u003c/code\u003e，是函数声明，不能执行 \u003ccode\u003efunction foo () {} ()\u003c/code\u003e。\u003ccode\u003elet foo = function () {}\u003c/code\u003e，函数表达式 \u003ccode\u003efunction () {}\u003c/code\u003e 也即是 \u003ccode\u003efoo\u003c/code\u003e，可以执行 \u003ccode\u003efoo()\u003c/code\u003e。\u003c/p\u003e\n\u003ch3\u003e函数表达式和函数声明\u003c/h3\u003e\n\u003ch4\u003e函数声明\u003c/h4\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function\"\u003ehttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function\u003c/a\u003e\n​\n\u003cstrong\u003e函数声明\u003c/strong\u003e定义一个具有指定参数的函数。\u003c/p\u003e\n\u003cp\u003e语法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ename\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e[param,[, param,[..., param]]]\u003c/span\u003e) \u003c/span\u003e{\n  [statements]\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003ename\u003c/code\u003e：函数名\n\u003ccode\u003eparam\u003c/code\u003e：要传递给函数的参数的名称。不同引擎中的最大参数数量不同。\n\u003ccode\u003estatements\u003c/code\u003e：包含函数体的语句。\u003c/p\u003e\n\u003cp\u003e函数声明或被提升到被包含的函数或全局作用域顶部，可以在声明前使用：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003ehoisted() \u003cspan class=\"hljs-comment\"\u003e// \"foo\"\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ehoisted\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'foo'\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-comment\"\u003e/* equal to*/\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e hoisted\nhoisted = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'foo'\u003c/span\u003e)\n}\nhoisted()\n\u003cspan class=\"hljs-comment\"\u003e// \"foo\"\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e而函数表达式不会被提升：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003enotHoisted() \u003cspan class=\"hljs-comment\"\u003e// TypeError: notHoisted is not a function\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e notHoisted = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'bar'\u003c/span\u003e)\n}\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e函数表达式\u003c/h4\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function\"\u003ehttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function\u003c/a\u003e\n​\n语法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003elet function*expression = function [name]([param1[, param2[, ..., paramN]]]) {\n  statements\n};\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003ename\u003c/code\u003e：函数名称。可被省略，此种情况下的函数是匿名函数（anonymous）。 函数名称只是函数体中的一个本地变量。\n\u003ccode\u003eparamN\u003c/code\u003e：被传递给函数的一个参数名称。一个函数至多拥有 255 个参数。\n\u003ccode\u003estatements\u003c/code\u003e：构成函数体的语句。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e从以上对比可以发现，函数表达式非常类似函数声明，唯一的区别就是函数名称可以省略，从而创建匿名函数。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e函数名称类似变量，会提升，不同的是，对于函数声明，变量（函数名称）会和变量赋值（函数体）一起提升，而变量不会，只提升变量声明。\u003c/p\u003e\n\u003cp\u003e以下是一个\u003cstrong\u003e命名函数表达式\u003c/strong\u003e，应用于递归中自我调用：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e math = {\n  \u003cspan class=\"hljs-string\"\u003e'factorial'\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efactorial\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003en\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (n \u0026lt;= \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e n \\* factorial(n - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n};\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e被函数表达式赋值的那个变量会有一个 name 属性，如果你把这个变量赋值给另一个变量的话，这个 name 属性的值也不会改变。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e foo = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{}\nfoo.name \u003cspan class=\"hljs-comment\"\u003e// \"foo\"\u003c/span\u003e\n;(\u003cspan class=\"hljs-string\"\u003e'foo'\u003c/span\u003e)\nfoo.name = \u003cspan class=\"hljs-string\"\u003e'aaa'\u003c/span\u003e\n;(\u003cspan class=\"hljs-string\"\u003e'aaa'\u003c/span\u003e)\nfoo.name\n;(\u003cspan class=\"hljs-string\"\u003e'foo'\u003c/span\u003e)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e实际上被赋值的变量引用了函数，函数名称是不变的。\u003c/p\u003e\n\u003cp\u003e函数表达式更多被当做回调函数使用：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003ebutton.addEventListener(\u003cspan class=\"hljs-string\"\u003e'click'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'button is clicked!'\u003c/span\u003e)\n})\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e函数声明就是语句，\u003ccode\u003efunction foo () {}\u003c/code\u003e，而函数表达式，\u003ccode\u003efunction () {}\u003c/code\u003e，本身是一个值，所以在回调中无法使用函数声明。\u003c/p\u003e\n\u003ch3\u003e使用对象字面量和函数表达式作为语句\u003c/h3\u003e\n\u003cp\u003e我们已经看到，一些表达式和语句是无法区分的，相同的代码作用不同，这取决于它出现在表达式上下文会还是语句上下文中。通常这两个上下文是明显分开的。但是，对于表达式语句，会有重叠：在这里，表达式出现在语句上下文中。为了避免歧义，JavaScript 语法禁止表达式语句以花括号或关键字 function 开头。\u003c/p\u003e\n\u003cp\u003e但是，如果你想写一个以 \u003ccode\u003e{\u003c/code\u003e 或 \u003ccode\u003efuncton\u003c/code\u003e 开头的表达式语句呢？ \u003cstrong\u003e你可以将它放在圆括号中，这样不会改变它的结果，而且可以确保它出现在表达式（expression-only）上下文中\u003c/strong\u003e。看两个例子：\u003ccode\u003eeval\u003c/code\u003e 和立即执行函数表达式（\u003ccode\u003eIIFE\u003c/code\u003e）。\u003c/p\u003e\n\u003ch4\u003eeval\u003c/h4\u003e\n\u003cp\u003eeval 在语句上下文中解析它的参数。如果你想让 eval 返回一个对象，可以给对象字面量加上圆括号：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-built_in\"\u003eeval\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'{ foo: 123 }'\u003c/span\u003e)\n\u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eeval\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'({ foo: 123 })'\u003c/span\u003e)\n{\n  \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003e立即执行函数表达式（IIFEs）\u003c/h4\u003e\n\u003cp\u003e以下是一个立即执行函数表达式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e;(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'abc'\u003c/span\u003e\n})()\n\u003cspan class=\"hljs-comment\"\u003e// 'abc'\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果省略括号，就会出现语法错误（函数声明不能是匿名的）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{ \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"abc\"\u003c/span\u003e }()\n\u003cspan class=\"hljs-attr\"\u003eVM6752\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e Uncaught \u003cspan class=\"hljs-built_in\"\u003eSyntaxError\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eFunction\u003c/span\u003e statements \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e a \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ename\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果加上名字，仍然报错（函数声明不能立即执行）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{ \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"abc\"\u003c/span\u003e }()\n\u003cspan class=\"hljs-attr\"\u003eVM6757\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e Uncaught \u003cspan class=\"hljs-built_in\"\u003eSyntaxError\u003c/span\u003e: Unexpected token )\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e另一个确保表达式在表达式上下文中被解析的方式是使用一元运算符，如 \u003ccode\u003e+\u003c/code\u003e 或 \u003ccode\u003e!\u003c/code\u003e。但是和圆括号相反，这些运算符会改变表达式结果。如果不需要也 OK。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e+\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{ \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e\"hello\"\u003c/span\u003e) }()\n\u003cspan class=\"hljs-attr\"\u003eVM6762\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e hello\n\u003cspan class=\"hljs-literal\"\u003eNaN\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e所以，IIFEs 的原理是：函数本不能作为表达式出现（指值 \u003ccode\u003efunction () {}\u003c/code\u003e，而不是表达式 \u003ccode\u003elet foo = function () {}\u003c/code\u003e），但是要立即执行函数，可以将其转为表达式，圆括号将其变为表达式。\u003c/p\u003e\n\u003ch4\u003e连接 IIFEs\u003c/h4\u003e\n\u003cp\u003e连接 IIFEs，不要忘记分号：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e;(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{})()((\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{})())\n\u003cspan class=\"hljs-comment\"\u003e// TypeError: undefined is not a function\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e参考\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Statement*(computer*science)\"\u003ehttps://en.wikipedia.org/wiki/Statement*(computer*science)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%BC%8F\"\u003ehttps://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%BC%8F\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Expression*(computer_science)\"\u003ehttps://en.wikipedia.org/wiki/Expression*(computer_science)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.zhihu.com/question/20750344/answer/487107831\"\u003ehttps://www.zhihu.com/question/20750344/answer/487107831\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://2ality.com/2012/09/expressions-vs-statements.html\"\u003ehttps://2ality.com/2012/09/expressions-vs-statements.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function\"\u003ehttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function\"\u003ehttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","preview":"语句\n\nwiki","dir":"content","base":"statement-and-expression.json","ext":".json","sourceBase":"statement-and-expression.md","sourceExt":".md"}}},"page":"/post","query":{"fullUrl":"/statement-and-expression"},"buildId":"iu6_5DrOPmhFOAN3PQyRD","nextExport":true,"isFallback":false,"gip":true}</script><script nomodule="" src="/_next/static/runtime/polyfills-b10afcedf826ebd862ad.js"></script><script async="" data-next-page="/_app" src="/_next/static/iu6_5DrOPmhFOAN3PQyRD/pages/_app.js"></script><script async="" data-next-page="/post" src="/_next/static/iu6_5DrOPmhFOAN3PQyRD/pages/post.js"></script><script src="/_next/static/runtime/webpack-58a9a31aff66d1589179.js" async=""></script><script src="/_next/static/chunks/framework.e84fa698c7ee940652bd.js" async=""></script><script src="/_next/static/chunks/commons.34684228d50c6c140f9e.js" async=""></script><script src="/_next/static/runtime/main-5879c6e8fc5fb6f8f0ea.js" async=""></script><script src="/_next/static/chunks/37fdf20fe8abb7e95e7de40a8be29264464a11e4.d421cefb44a0017721ac.js" async=""></script><script src="/_next/static/iu6_5DrOPmhFOAN3PQyRD/_buildManifest.js" async=""></script><script src="/_next/static/iu6_5DrOPmhFOAN3PQyRD/_ssgManifest.js" async=""></script></body></html>